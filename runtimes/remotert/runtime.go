package remotert

import (
	"context"
	"fmt"
	"io/fs"

	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials/insecure"

	"go.autokitteh.dev/autokitteh/internal/backend/logger"
	"go.autokitteh.dev/autokitteh/internal/kittehs"
	"go.autokitteh.dev/autokitteh/runtimes/remotert/pb"

	"go.autokitteh.dev/autokitteh/sdk/sdkruntimes"
	"go.autokitteh.dev/autokitteh/sdk/sdkservices"
	"go.autokitteh.dev/autokitteh/sdk/sdktypes"
	"go.uber.org/zap"
)

var (
	Runtime = &sdkruntimes.Runtime{
		Desc: kittehs.Must1(sdktypes.StrictRuntimeFromProto(&sdktypes.RuntimePB{
			Name:           "remote",
			FileExtensions: []string{"py"},
		})),
		New: New,
	}
	config RemoteRuntimeConfig
	runner pb.RunnerManagerClient
)

type svc struct{}

func (*svc) Get() sdktypes.Runtime {
	return sdktypes.Runtime{}
}

// Returns sdktypes.ProgramErrorAsError if not internal error.
func (*svc) Build(ctx context.Context, fs fs.FS, path string, symbols []sdktypes.Symbol) (sdktypes.BuildArtifact, error) {
	return sdktypes.InvalidBuildArtifact, nil
}

// Returns sdktypes.ProgramErrorAsError if not internal error.
func (*svc) Run(
	ctx context.Context,
	rid sdktypes.RunID, // generated by caller. guaranteed to be unique system-wide.
	path string, // where to start running from.
	compiled map[string][]byte,
	values map[string]sdktypes.Value,
	cbs *sdkservices.RunCallbacks,
) (sdkservices.Run, error) {
	return nil, nil
}

func Configure(cfg RemoteRuntimeConfig) error {
	if err := cfg.validate(); err != nil {
		return err
	}

	addr := cfg.RunnerAddress[0]

	creds := insecure.NewCredentials()
	conn, err := grpc.NewClient(addr, grpc.WithTransportCredentials(creds))
	if err != nil {
		return err
	}

	runner = pb.NewRunnerManagerClient(conn)
	resp, err := runner.Health(context.Background(), &pb.HealthRequest{})
	if err != nil {
		return fmt.Errorf("could not verify runner manager health")
	}
	if resp.Error != "" {
		return fmt.Errorf("runner manager health: %w", err)
	}

	// c := &http.Client{
	// 	Transport: &http2.Transport{
	// 		AllowHTTP: true,
	// 		DialTLS: func(network, addr string, cfg *tls.Config) (net.Conn, error) {
	// 			return net.Dial(network, addr)
	// 		},
	// 	},
	// }

	// runner = runner_managerv1connect.NewRunnerManagerServiceClient(c, addr, connect.WithGRPC())

	// resp, err := runner.Health(context.Background(), &connect.Request[runner_managerv1.HealthRequest]{})
	// if err != nil {
	// 	return fmt.Errorf("could not verify runner manager health")
	// }
	// if resp.Msg.Error != "" {
	// 	return fmt.Errorf("runner manager health error: %w", err)
	// }
	config = cfg

	return nil
}

func New() (sdkservices.Runtime, error) {
	log, err := logger.New(logger.Configs.Default)
	if err != nil {
		return nil, err
	}

	log = log.With(zap.String("runtime", "remote"))
	if err := config.validate(); err != nil {
		return nil, fmt.Errorf("remotert: invalid config %w", err)
	}

	if runner == nil {
		return nil, fmt.Errorf("runner not started")
	}

	s := svc{}

	return &s, nil
}
