package remotert

import (
	"context"
	"fmt"

	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials/insecure"

	"go.autokitteh.dev/autokitteh/internal/backend/logger"
	"go.autokitteh.dev/autokitteh/internal/kittehs"
	"go.autokitteh.dev/autokitteh/runtimes/remotert/pb"

	"go.autokitteh.dev/autokitteh/sdk/sdkruntimes"
	"go.autokitteh.dev/autokitteh/sdk/sdkservices"
	"go.autokitteh.dev/autokitteh/sdk/sdktypes"
	"go.uber.org/zap"
)

var (
	Runtime = &sdkruntimes.Runtime{
		Desc: kittehs.Must1(sdktypes.StrictRuntimeFromProto(&sdktypes.RuntimePB{
			Name:           "remote",
			FileExtensions: []string{"py"},
		})),
		New: New,
	}
	config RemoteRuntimeConfig
	runner pb.RunnerManagerClient
)

func (*svc) Get() sdktypes.Runtime {
	return Runtime.Desc
}

func (s *svc) Call(ctx context.Context, v sdktypes.Value, args []sdktypes.Value, kwargs map[string]sdktypes.Value) (sdktypes.Value, error) {
	if s.firstCall {
		s.firstCall = false
		s.runnerClient.Start(context.Background(), &pb.StartRequest{RunId: s.runID.String(), EntryPoint: s.mainPath})
	}
	s.runnerClient.Execute(context.Background(), &pb.ExecuteRequest{})
	return sdktypes.InvalidValue, nil
}

func (s *svc) ID() sdktypes.RunID {
	return s.runID.ToRunID()
}

func (s *svc) Close() {
	resp, err := runner.Stop(context.Background(), &pb.StopRequest{RunnerId: s.runnerID})
	if err != nil {
		fmt.Println(fmt.Sprintf("error calling stop runner :%w", err))
	}

	if resp.Error != "" {
		fmt.Println(fmt.Sprintf("stop runner returned error :%w", resp.Error))
	}
}

func (s *svc) ExecutorID() sdktypes.ExecutorID { return s.runID }

func (s *svc) Values() map[string]sdktypes.Value {
	return s.exports
}

type svc struct {
	runID         sdktypes.ExecutorID
	cbs           *sdkservices.RunCallbacks
	runnerID      string
	runnerAddress string
	runnerClient  pb.RunnerClient
	firstCall     bool
	mainPath      string
	exports       map[string]sdktypes.Value
}

// Returns sdktypes.ProgramErrorAsError if not internal error.
func (s *svc) Run(
	ctx context.Context,
	runID sdktypes.RunID, // generated by caller. guaranteed to be unique system-wide.
	mainPath string, // where to start running from.
	compiled map[string][]byte,
	values map[string]sdktypes.Value,
	cbs *sdkservices.RunCallbacks,
) (sdkservices.Run, error) {
	s.runID = sdktypes.NewExecutorID(runID) // Should be first
	s.mainPath = mainPath
	s.cbs = cbs
	s.firstCall = true // State for Call.

	// Load environment defined by user in the `vars` section of the manifest,
	// these are injected to the Python subprocess environment.
	env, err := cbs.Load(ctx, runID, "env")
	if err != nil {
		return nil, fmt.Errorf("can't load env : %w", err)
	}
	envMap := kittehs.TransformMap(env, func(key string, value sdktypes.Value) (string, string) {
		return key, value.GetString().Value()
	})
	// py.log.Info("env", zap.Any("env", envMap))

	tarData := compiled["archive"]
	if tarData == nil {
		return nil, fmt.Errorf("%q note found in compiled data", "archive")
	}

	resp, err := runner.Start(ctx, &pb.StartRunnerRequest{BuildArtifact: tarData, Vars: envMap, WorkerAddress: "localhost:9980"})
	if err != nil {
		return nil, fmt.Errorf("staring runner %w", err)
	}

	if resp.Error != "" {
		return nil, fmt.Errorf("staring runner %w", resp.Error)
	}

	s.runnerID = resp.RunnerId
	s.runnerAddress = resp.RunnerAddress

	creds := insecure.NewCredentials()
	conn, err := grpc.NewClient(s.runnerAddress, grpc.WithTransportCredentials(creds))
	if err != nil {
		return nil, err
	}

	s.runnerClient = pb.NewRunnerClient(conn)
	rh, err := s.runnerClient.Health(ctx, &pb.HealthRequest{})
	if err != nil {
		return nil, fmt.Errorf("could not verify runner health %w", err)
	}
	if rh.Error != "" {
		return nil, fmt.Errorf("runner health: %w", err)
	}

	exports, err := s.runnerClient.Exports(context.Background(), &pb.ExportsRequest{})
	if err != nil || exports.Error != "" {
		return nil, fmt.Errorf("failed fetching exports")
	}

	s.exports = kittehs.ListToMap(exports.Exports, func(e string) (string, sdktypes.Value) {
		return e, sdktypes.NewStringValue(e)
	})
	// exports.Exports

	return s, nil

}

func Configure(cfg RemoteRuntimeConfig) error {
	if err := cfg.validate(); err != nil {
		return err
	}

	addr := cfg.ManagerAddress[0]

	creds := insecure.NewCredentials()
	conn, err := grpc.NewClient(addr, grpc.WithTransportCredentials(creds))
	if err != nil {
		return err
	}

	runner = pb.NewRunnerManagerClient(conn)
	resp, err := runner.Health(context.Background(), &pb.HealthRequest{})
	if err != nil {
		return fmt.Errorf("could not verify runner manager health")
	}
	if resp.Error != "" {
		return fmt.Errorf("runner manager health: %w", err)
	}

	// c := &http.Client{
	// 	Transport: &http2.Transport{
	// 		AllowHTTP: true,
	// 		DialTLS: func(network, addr string, cfg *tls.Config) (net.Conn, error) {
	// 			return net.Dial(network, addr)
	// 		},
	// 	},
	// }

	// runner = runner_managerv1connect.NewRunnerManagerServiceClient(c, addr, connect.WithGRPC())

	// resp, err := runner.Health(context.Background(), &connect.Request[runner_managerv1.HealthRequest]{})
	// if err != nil {
	// 	return fmt.Errorf("could not verify runner manager health")
	// }
	// if resp.Msg.Error != "" {
	// 	return fmt.Errorf("runner manager health error: %w", err)
	// }
	config = cfg

	return nil
}

func New() (sdkservices.Runtime, error) {
	log, err := logger.New(logger.Configs.Default)
	if err != nil {
		return nil, err
	}

	log = log.With(zap.String("runtime", "remote"))
	if err := config.validate(); err != nil {
		return nil, fmt.Errorf("remotert: invalid config %w", err)
	}

	if runner == nil {
		return nil, fmt.Errorf("runner not started")
	}

	s := svc{}

	return &s, nil
}
